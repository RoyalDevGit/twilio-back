import mongoose, {
  Schema,
  Document,
  Types,
  PaginateModel,
  PipelineStage,
} from 'mongoose'
import mongoosePaginate from 'mongoose-paginate-v2'
import mongooseAutopopulate from 'mongoose-autopopulate'
import { DateTime } from 'luxon'

import { User } from 'models/User'
import { ModelRef } from 'interfaces/ModelRef'
import { pick } from 'utils/object/pick'
import { getEnumValues } from 'utils/enum/enumUtils'
import { Expert } from 'models/Expert'
import { FileTracker, FileTrackerModel } from 'models/FileTracker'
import { AverageRatings, AverageRatingsSchema } from 'models/Comment'
import { paginateAggregationPipeline } from 'utils/pagination/paginateAggregationPipeline'
import { QueryRequest, QueryResponse } from 'interfaces/Query'
import { VideoFavorite, VideoFavoriteModel } from 'models/VideoFavorite'

export enum VideoType {
  ExpertIntro = 'expert_intro',
  Content = 'content',
  SessionRecording = 'session_recording',
}

export enum VideoStatus {
  Draft = 'draft',
  Uploaded = 'uploaded',
  Published = 'published',
}

export enum VideoVisibility {
  Public = 'public',
  Private = 'private',
  Unlisted = 'unlisted',
}

export enum VideoAudience {
  Everyone = 'everyone',
  Adults = 'adults',
}

export enum VideoThumbnailType {
  AutoGenerated = 'auto_generated',
  Custom = 'custom',
}

export interface VideoThumbnail extends Types.Subdocument {
  file: ModelRef<FileTracker>
  thumbnailType: VideoThumbnailType
  createdBy: ModelRef<User>
  uploaded: Date
}

const VideoThumbnailSchema = new Schema<VideoThumbnail>({
  file: {
    type: Schema.Types.ObjectId,
    ref: 'FileTracker',
    required: true,
    immutable: true,
  },
  thumbnailType: {
    type: String,
    required: true,
    immutable: true,
    trim: true,
    enum: getEnumValues(VideoThumbnailType),
  },
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    immutable: true,
  },
  uploaded: {
    type: Date,
    required: true,
    immutable: true,
    default: (): Date => DateTime.utc().toJSDate(),
  },
})

const serializeVideoThumbnail = (
  thumbnail: Partial<VideoThumbnail>
): Partial<VideoThumbnail> =>
  pick(
    thumbnail,
    'id',
    'file',
    'thumbnailType',
    'createdBy',
    'uploaded'
  ) as Partial<VideoThumbnail>

VideoThumbnailSchema.methods.toJSON = function (
  this: VideoThumbnail
): Partial<VideoThumbnail> {
  return serializeVideoThumbnail(this)
}

export interface Video extends Document {
  videoType: VideoType
  file: ModelRef<FileTracker>
  title: string
  description?: string
  thumbnails: Types.DocumentArray<VideoThumbnail>
  selectedThumbnail: string
  visibility: VideoVisibility
  audience: VideoAudience
  madeForKids: boolean
  tags: string[]
  language?: string
  status: VideoStatus
  expert?: ModelRef<Expert>
  createdBy: ModelRef<User>
  uploaded: Date
  averageRatings: AverageRatings
  totalFavorites: number
  isFavorite: boolean
  containsPaidPromotion: boolean
}

const requiredIfPublished = function (this: Video) {
  return this.status === VideoStatus.Published
}

const VideoSchema = new Schema<Video>(
  {
    videoType: {
      type: String,
      required: true,
      trim: true,
      enum: getEnumValues(VideoType),
      default: VideoType.Content,
    },
    file: {
      type: Schema.Types.ObjectId,
      ref: 'FileTracker',
      required: true,
      immutable: true,
      autopopulate: true,
    },
    title: { type: String, required: requiredIfPublished, trim: true },
    description: { type: String, trim: true },
    thumbnails: [{ type: VideoThumbnailSchema, required: true }],
    selectedThumbnail: {
      type: String,
      trim: true,
    },
    visibility: {
      type: String,
      required: requiredIfPublished,
      trim: true,
      enum: getEnumValues(VideoVisibility),
    },
    audience: {
      type: String,
      required: requiredIfPublished,
      trim: true,
      enum: getEnumValues(VideoAudience),
    },
    madeForKids: { type: Boolean, required: requiredIfPublished },
    tags: [{ type: String, trim: true }],
    language: {
      type: String,
    },
    expert: { type: Schema.Types.ObjectId, ref: 'Expert' },
    status: {
      type: String,
      trim: true,
      enum: getEnumValues(VideoStatus),
      default: VideoStatus.Draft,
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      immutable: true,
    },
    uploaded: {
      type: Date,
      required: true,
      immutable: true,
      default: (): Date => DateTime.utc().toJSDate(),
    },
    averageRatings: {
      type: AverageRatingsSchema,
    },
    totalFavorites: { type: Number, default: 0, min: 0 },
    containsPaidPromotion: { type: Boolean, default: false },
  },
  { timestamps: true }
)

VideoSchema.plugin(mongoosePaginate)

const serializeVideo = (video: Partial<Video>): Partial<Video> =>
  pick(
    video,
    'id',
    'videoType',
    'file',
    'title',
    'description',
    'thumbnails',
    'selectedThumbnail',
    'visibility',
    'audience',
    'madeForKids',
    'tags',
    'language',
    'status',
    'createdBy',
    'uploaded',
    'expert',
    'averageRatings',
    'totalFavorites',
    'isFavorite',
    'containsPaidPromotion'
  ) as Partial<Video>

VideoSchema.methods.toJSON = function (this: Video): Partial<Video> {
  return serializeVideo(this)
}

VideoSchema.plugin(mongooseAutopopulate)

interface VideoQueryOptions extends QueryRequest {
  expertId?: string
}

VideoSchema.static('query', async (options: VideoQueryOptions) => {
  const { expertId } = options
  const pipeline: PipelineStage[] = [
    {
      $project: {
        _id: 0,
        video: '$$ROOT',
      },
    },
    {
      $lookup: {
        localField: 'video.thumbnails.file',
        from: 'filetrackers',
        foreignField: '_id',
        as: 'thumbnailFileTrackers',
      },
    },
    {
      $lookup: {
        localField: 'video._id',
        from: 'videofavorites',
        foreignField: 'video',
        as: 'videoFavorite',
      },
    },
    {
      $unwind: {
        path: '$videoFavorite',
        preserveNullAndEmptyArrays: true,
      },
    },
  ]

  if (expertId) {
    pipeline.push({
      $match: {
        'video.expert': new mongoose.Types.ObjectId(expertId),
      },
    })
  }

  interface AggregateResult {
    video: Video
    videoFavorite?: VideoFavorite
    thumbnailFileTrackers: FileTracker[]
  }

  const queryResponse = await paginateAggregationPipeline<
    Video,
    AggregateResult
  >({
    model: VideoModel,
    paginationRequest: options,
    pipeline,
    resultMapper: (item) => {
      const video = new VideoModel(item.video)
      video.isFavorite = !!item.videoFavorite
      video.thumbnails.forEach((thumb) => {
        const thumbFileTracker = item.thumbnailFileTrackers.find((f) =>
          new mongoose.Types.ObjectId(
            thumb.file as unknown as mongoose.Types.ObjectId
          ).equals(f._id)
        )
        if (thumbFileTracker) {
          thumb.file = new FileTrackerModel(thumbFileTracker)
        }
      })
      return video
    },
  })

  return queryResponse
})

VideoSchema.static(
  'queryUserFavorites',
  async (userId: string, options: VideoQueryOptions) => {
    const { expertId } = options
    const pipeline: PipelineStage[] = [
      {
        $project: {
          _id: 0,
          videoFavorite: '$$ROOT',
        },
      },
      {
        $match: {
          'videoFavorite.user': new mongoose.Types.ObjectId(userId),
        },
      },
      {
        $lookup: {
          localField: 'videoFavorite.video',
          from: 'videos',
          foreignField: '_id',
          as: 'video',
        },
      },
      {
        $unwind: {
          path: '$video',
          preserveNullAndEmptyArrays: true,
        },
      },
      {
        $lookup: {
          localField: 'video.thumbnails.file',
          from: 'filetrackers',
          foreignField: '_id',
          as: 'thumbnailFileTrackers',
        },
      },
      {
        $lookup: {
          localField: 'video._id',
          from: 'videofavorites',
          foreignField: 'video',
          as: 'videoFavorite',
        },
      },
      {
        $unwind: {
          path: '$videoFavorite',
          preserveNullAndEmptyArrays: true,
        },
      },
    ]

    if (expertId) {
      pipeline.push({
        $match: {
          'video.expert': new mongoose.Types.ObjectId(expertId),
        },
      })
    }

    interface AggregateResult {
      video: Video
      videoFavorite?: VideoFavorite
      thumbnailFileTrackers: FileTracker[]
    }

    const queryResponse = await paginateAggregationPipeline<
      Video,
      AggregateResult
    >({
      model: VideoFavoriteModel,
      paginationRequest: options,
      pipeline,
      resultMapper: (item) => {
        const video = new VideoModel(item.video)
        video.isFavorite = !!item.videoFavorite
        video.thumbnails.forEach((thumb) => {
          const thumbFileTracker = item.thumbnailFileTrackers.find((f) =>
            new mongoose.Types.ObjectId(
              thumb.file as unknown as mongoose.Types.ObjectId
            ).equals(f._id)
          )
          if (thumbFileTracker) {
            thumb.file = new FileTrackerModel(thumbFileTracker)
          }
        })
        return video
      },
    })

    return queryResponse
  }
)

interface IVideoModel extends PaginateModel<Video> {
  query(options: VideoQueryOptions): Promise<QueryResponse<Video>>
  queryUserFavorites(
    userId: string,
    options: VideoQueryOptions
  ): Promise<QueryResponse<Video>>
}

export const VideoModel = mongoose.model<Video, IVideoModel>(
  'Video',
  VideoSchema
)
